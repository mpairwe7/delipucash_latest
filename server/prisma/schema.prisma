generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model AppUser {
  id                       String                @id @default(uuid()) @db.Uuid
  email                    String                @unique
  password                 String
  firstName                String
  lastName                 String
  phone                    String
  points                   Int                   @default(0)
  avatar                   String?               @default("https://cdn.pixabay.com/photo/2015/10/05/22/37/blank-profile-picture-973460_1280.png")
  role                     UserRole?             @default(USER)
  twoFactorEnabled         Boolean               @default(false)
  twoFactorCode            String?               // Hashed OTP code
  twoFactorCodeExpiry      DateTime?             // OTP expiration time
  passwordResetToken       String?               // Hashed password reset token
  passwordResetExpiry      DateTime?             // Password reset token expiration
  subscriptionStatus       SubscriptionStatus    @default(INACTIVE)
  surveysubscriptionStatus SubscriptionStatus    @default(INACTIVE)
  currentSubscriptionId    String?               @db.Uuid
  privacySettings          Json?
  createdAt                DateTime              @default(now())
  updatedAt                DateTime              @updatedAt
  Ad                       Ad[]
  Comment                  Comment[]
  instantRewardWinners     InstantRewardWinner[]
  loginSessions            LoginSession[]
  notifications            Notification[]
  payments                 Payment[]
  questions                Question[]
  questionVotes            QuestionVote[]
  attempts                 QuestionAttempt[]
  Response                 Response[]
  responseDislikes         ResponseDislike[]
  responseLikes            ResponseLike[]
  responseReplies          ResponseReply[]
  rewards                  Reward[]
  rewardQuestions          RewardQuestion[]
  surveys                  Survey[]
  UploadQuestionQuestion   UploadQuestion[]
  UploadSurvey             UploadSurvey[]
  videos                   Video[]
  SurveyResponse           SurveyResponse[]
}

model Video {
  id            String    @id @default(uuid()) @db.Uuid
  title         String?
  description   String?
  videoUrl      String
  thumbnail     String
  userId        String    @db.Uuid
  likes         Int       @default(0)
  views         Int       @default(0)
  duration      Int?      // Duration in seconds (optional for upload, can be extracted from video)
  isBookmarked  Boolean   @default(false)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  commentsCount Int       @default(0)
  
  // R2 Storage Metadata (Cloudflare R2 / S3-compatible)
  r2VideoKey       String?   // R2 object key for video file
  r2ThumbnailKey   String?   // R2 object key for thumbnail
  r2VideoEtag      String?   // ETag for cache validation
  r2ThumbnailEtag  String?   // ETag for thumbnail cache validation
  videoMimeType    String?   // Video MIME type (e.g., video/mp4)
  thumbnailMimeType String?  // Thumbnail MIME type (e.g., image/jpeg)
  videoSizeBytes   BigInt?   // Video file size in bytes
  thumbnailSizeBytes Int?    // Thumbnail file size in bytes
  storageProvider  String    @default("r2") // Storage provider: r2, supabase, uploadcare, etc.
  isProcessed      Boolean   @default(false) // Whether video has been processed (transcoding, etc.)
  processingStatus String?   // Processing status: pending, processing, completed, failed
  
  comments      Comment[]
  user          AppUser   @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([r2VideoKey])
}

model Livestream {
  id                String    @id @default(uuid()) @db.Uuid
  sessionId         String    @unique // Unique session identifier
  userId            String    @db.Uuid
  title             String?
  description       String?
  status            String    @default("pending") // pending, live, ended, failed
  streamKey         String?   // Unique stream key for the session
  
  // Timing
  startedAt         DateTime?
  endedAt           DateTime?
  scheduledStartAt  DateTime?
  durationSeconds   Int?      // Actual duration in seconds
  maxDurationSeconds Int      @default(300) // Max allowed duration based on user tier
  
  // Metrics
  viewerCount       Int       @default(0)
  peakViewerCount   Int       @default(0)
  
  // R2 Storage for recording
  r2RecordingKey    String?   // R2 object key for the recording
  r2ThumbnailKey    String?   // R2 object key for thumbnail
  recordingUrl      String?   // Public/signed URL for playback
  thumbnailUrl      String?
  recordingSizeBytes BigInt?
  
  // Metadata
  isRecordingEnabled Boolean  @default(true)
  isPremium          Boolean  @default(false)
  
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([userId])
  @@index([sessionId])
  @@index([status])
}

model Comment {
  id        String   @id @default(uuid()) @db.Uuid
  text      String
  mediaUrls String[] @default([])
  userId    String   @db.Uuid
  videoId   String   @db.Uuid
  createdAt DateTime @default(now())
  user      AppUser  @relation(fields: [userId], references: [id])
  video     Video    @relation(fields: [videoId], references: [id])
}

model Survey {
  id             String           @id @default(uuid()) @db.Uuid
  title          String
  description    String?
  userId         String           @db.Uuid
  rewardAmount   Float            @default(2000)
  maxResponses   Int?
  startDate      DateTime
  endDate        DateTime
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  user           AppUser          @relation(fields: [userId], references: [id])
  uploads        UploadSurvey[]
  SurveyResponse SurveyResponse[]
}

model UploadSurvey {
  id          String   @id @default(uuid()) @db.Uuid
  text        String
  type        String
  options     String
  placeholder String?
  minValue    Int?
  maxValue    Int?
  userId      String   @db.Uuid
  surveyId    String   @db.Uuid
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  survey      Survey   @relation(fields: [surveyId], references: [id])
  user        AppUser  @relation(fields: [userId], references: [id])
}

model Ad {
  id                String    @id @default(uuid()) @db.Uuid
  title             String
  description       String
  headline          String?
  imageUrl          String?
  videoUrl          String?
  thumbnailUrl      String?
  type              String    @default("regular")
  placement         String    @default("feed")
  sponsored         Boolean   @default(false)
  views             Int       @default(0)
  clicks            Int       @default(0)
  impressions       Int       @default(0)
  conversions       Int       @default(0)
  isActive          Boolean   @default(true)
  startDate         DateTime?
  endDate           DateTime?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  userId            String    @db.Uuid
  priority          Int       @default(5)
  frequency         Int?
  lastShown         DateTime?
  targetUrl         String?
  callToAction      String    @default("learn_more")
  pricingModel      String    @default("cpm")
  totalBudget       Float     @default(0)
  bidAmount         Float     @default(0)
  dailyBudgetLimit  Float?
  amountSpent       Float     @default(0)
  targetAgeRanges   Json?
  targetGender      String    @default("all")
  targetLocations   Json?
  targetInterests   Json?
  enableRetargeting Boolean   @default(false)
  status            String    @default("pending")
  rejectionReason   String?
  approvedAt        DateTime?
  approvedBy        String?   @db.Uuid
  
  // R2 Storage Metadata (Cloudflare R2 / S3-compatible) - similar to Video model
  r2ImageKey        String?   // R2 object key for image file
  r2VideoKey        String?   // R2 object key for video file
  r2ThumbnailKey    String?   // R2 object key for thumbnail
  r2ImageEtag       String?   // ETag for image cache validation
  r2VideoEtag       String?   // ETag for video cache validation
  r2ThumbnailEtag   String?   // ETag for thumbnail cache validation
  imageMimeType     String?   // Image MIME type (e.g., image/jpeg)
  videoMimeType     String?   // Video MIME type (e.g., video/mp4)
  thumbnailMimeType String?   // Thumbnail MIME type (e.g., image/jpeg)
  imageSizeBytes    BigInt?   // Image file size in bytes
  videoSizeBytes    BigInt?   // Video file size in bytes
  thumbnailSizeBytes Int?     // Thumbnail file size in bytes
  storageProvider   String    @default("r2") // Storage provider: r2, supabase, uploadcare, etc.
  
  user              AppUser   @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([type])
  @@index([placement])
  @@index([isActive])
  @@index([priority])
  @@index([lastShown])
  @@index([status])
  @@index([pricingModel])
  @@index([r2ImageKey])
  @@index([r2VideoKey])
}

model SurveyResponse {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @db.Uuid
  surveyId  String   @db.Uuid
  responses String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  survey    Survey   @relation(fields: [surveyId], references: [id])
  user      AppUser  @relation(fields: [userId], references: [id])

  // Industry standard: Enforce single attempt per user per survey at database level
  @@unique([userId, surveyId], name: "unique_user_survey_attempt")
  @@index([userId])
  @@index([surveyId])
  @@map("survey_responses")
}

model RewardQuestion {
  id              String                    @id @default(uuid()) @db.Uuid
  text            String
  options         Json
  correctAnswer   String
  rewardAmount    Int                       @default(0)
  expiryTime      DateTime?
  isActive        Boolean                   @default(true)
  userId          String                    @db.Uuid
  createdAt       DateTime                  @default(now())
  updatedAt       DateTime                  @updatedAt
  isInstantReward Boolean                   @default(false)
  maxWinners      Int                       @default(2)
  winnersCount    Int                       @default(0)
  isCompleted     Boolean                   @default(false)
  paymentProvider String?
  phoneNumber     String?
  winners         InstantRewardWinner[]
  user            AppUser                   @relation(fields: [userId], references: [id])
  attempts        RewardQuestionOnAttempt[]

  @@index([userId])
  @@index([isActive])
  @@index([expiryTime])
  @@index([isInstantReward])
  @@index([isCompleted])
}

model RewardQuestionOnAttempt {
  id                String          @id @default(uuid()) @db.Uuid
  rewardQuestionId  String          @db.Uuid
  questionAttemptId String          @db.Uuid
  questionAttempt   QuestionAttempt @relation(fields: [questionAttemptId], references: [id])
  rewardQuestion    RewardQuestion  @relation(fields: [rewardQuestionId], references: [id])

  @@index([rewardQuestionId, questionAttemptId])
}

model InstantRewardWinner {
  id               String         @id @default(uuid()) @db.Uuid
  rewardQuestionId String         @db.Uuid
  userEmail        String
  position         Int
  amountAwarded    Int
  paymentStatus    PaymentStatus  @default(PENDING)
  paymentReference String?
  paymentProvider  String?
  phoneNumber      String?
  paidAt           DateTime?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  rewardQuestion   RewardQuestion @relation(fields: [rewardQuestionId], references: [id])
  user             AppUser        @relation(fields: [userEmail], references: [email])

  @@unique([rewardQuestionId, userEmail])
  @@index([rewardQuestionId])
  @@index([userEmail])
  @@index([paymentStatus])
}

model Question {
  id              String            @id @default(uuid()) @db.Uuid
  text            String
  userId          String?           @db.Uuid
  category        String            @default("General")
  rewardAmount    Float             @default(0)
  isInstantReward Boolean           @default(false)
  viewCount       Int               @default(0)
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  user            AppUser?          @relation(fields: [userId], references: [id])
  attempts        QuestionAttempt[]
  responses       Response[]
  votes           QuestionVote[]
}

model QuestionVote {
  id         String   @id @default(uuid()) @db.Uuid
  userId     String   @db.Uuid
  questionId String   @db.Uuid
  type       String   // 'up' or 'down'
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  user       AppUser  @relation(fields: [userId], references: [id])
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([userId, questionId])
  @@index([questionId])
  @@index([userId])
}

model Response {
  id           String            @id @default(uuid()) @db.Uuid
  responseText String
  userId       String            @db.Uuid
  questionId   String            @db.Uuid
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt
  question     Question          @relation(fields: [questionId], references: [id])
  user         AppUser           @relation(fields: [userId], references: [id])
  dislikes     ResponseDislike[]
  likes        ResponseLike[]
  replies      ResponseReply[]

  @@index([userId, questionId])
}

model ResponseLike {
  id         String   @id @default(uuid()) @db.Uuid
  userId     String   @db.Uuid
  responseId String   @db.Uuid
  createdAt  DateTime @default(now())
  response   Response @relation(fields: [responseId], references: [id])
  user       AppUser  @relation(fields: [userId], references: [id])

  @@unique([userId, responseId])
  @@index([responseId])
}

model ResponseDislike {
  id         String   @id @default(uuid()) @db.Uuid
  userId     String   @db.Uuid
  responseId String   @db.Uuid
  createdAt  DateTime @default(now())
  response   Response @relation(fields: [responseId], references: [id])
  user       AppUser  @relation(fields: [userId], references: [id])

  @@unique([userId, responseId])
  @@index([responseId])
}

model ResponseReply {
  id         String   @id @default(uuid()) @db.Uuid
  replyText  String
  userId     String   @db.Uuid
  responseId String   @db.Uuid
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  response   Response @relation(fields: [responseId], references: [id])
  user       AppUser  @relation(fields: [userId], references: [id])

  @@index([responseId])
  @@index([userId])
}

model UploadQuestion {
  id             String   @id @default(uuid()) @db.Uuid
  text           String
  type           String
  options        String[]
  correctAnswers String[]
  placeholder    String?
  minValue       Int?
  maxValue       Int?
  userId         String   @db.Uuid
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  user           AppUser  @relation(fields: [userId], references: [id])
}

model QuestionAttempt {
  id              String                    @id @default(uuid()) @db.Uuid
  userEmail       String
  questionId      String                    @db.Uuid
  selectedAnswer  String
  isCorrect       Boolean
  attemptedAt     DateTime                  @default(now())
  question        Question                  @relation(fields: [questionId], references: [id])
  user            AppUser                   @relation(fields: [userEmail], references: [email])
  rewardQuestions RewardQuestionOnAttempt[]

  @@index([userEmail, questionId])
}

model Reward {
  id          String   @id @default(uuid()) @db.Uuid
  userEmail   String
  points      Int
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        AppUser  @relation(fields: [userEmail], references: [email])

  @@index([userEmail])
}

model Payment {
  id               String           @id @default(uuid()) @db.Uuid
  amount           Float
  phoneNumber      String
  provider         String
  TransactionId    String           @unique
  status           PaymentStatus    @default(PENDING)
  subscriptionType SubscriptionType
  startDate        DateTime
  endDate          DateTime
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  userId           String           @db.Uuid
  user             AppUser          @relation(fields: [userId], references: [id])

  @@index([userId, status])
}

model Notification {
  id          String               @id @default(uuid()) @db.Uuid
  userId      String               @db.Uuid
  title       String
  body        String
  type        NotificationType
  priority    NotificationPriority @default(MEDIUM)
  icon        String?
  imageUrl    String?
  actionUrl   String?
  actionText  String?
  metadata    Json?
  category    String?
  read        Boolean              @default(false)
  readAt      DateTime?
  archived    Boolean              @default(false)
  archivedAt  DateTime?
  delivered   Boolean              @default(false)
  deliveredAt DateTime?
  expiresAt   DateTime?
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt
  user        AppUser              @relation(fields: [userId], references: [id])

  @@index([userId, read, createdAt])
  @@index([userId, type])
  @@index([userId, priority])
  @@index([expiresAt])
}

model LoginSession {
  id           String    @id @default(uuid()) @db.Uuid
  userId       String    @db.Uuid
  deviceInfo   Json?
  ipAddress    String?
  userAgent    String?
  location     String?
  isActive     Boolean   @default(true)
  lastActivity DateTime  @default(now())
  loginTime    DateTime  @default(now())
  logoutTime   DateTime?
  sessionToken String?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  user         AppUser   @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([isActive])
  @@index([sessionToken])
}

enum PaymentStatus {
  PENDING
  SUCCESSFUL
  FAILED
}

enum SubscriptionStatus {
  ACTIVE
  INACTIVE
  PENDING
}

enum surveysubscriptionStatus {
  ACTIVE
  INACTIVE
  PENDING
}

enum SubscriptionType {
  ONCE
  DAILY
  WEEKLY
  MONTHLY
  QUARTERLY
  HALF_YEARLY
  YEARLY
  LIFETIME
}

enum UserRole {
  USER
  ADMIN
  MODERATOR
}

enum NotificationType {
  PAYMENT_SUCCESS
  PAYMENT_FAILED
  PAYMENT_PENDING
  REWARD_EARNED
  REWARD_REDEEMED
  SURVEY_COMPLETED
  SURVEY_EXPIRING
  SUBSCRIPTION_ACTIVE
  SUBSCRIPTION_EXPIRED
  SECURITY_ALERT
  SYSTEM_UPDATE
  PROMOTIONAL
  ACHIEVEMENT
  REFERRAL_BONUS
  WELCOME
}

enum NotificationPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

// SSE Event Log â€” stores events for Server-Sent Events delivery.
// Controllers write events after mutations; the SSE endpoint polls this table.
// Events are short-lived (10-minute TTL) and cleaned up automatically.
model SSEEvent {
  id        String   @id @default(uuid()) @db.Uuid
  seq       Int      @default(autoincrement())
  userId    String   @db.Uuid
  type      String   // e.g., "notification.new", "question.response", "payment.status"
  payload   Json
  createdAt DateTime @default(now())

  @@index([userId, seq])
  @@index([createdAt])
}
